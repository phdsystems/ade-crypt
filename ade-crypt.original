#!/bin/bash

# ADE-Crypt - Encryption/Decryption utility for PHD-ADE
# Provides file, directory, and secret management capabilities

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
MAGENTA='\033[0;35m'
NC='\033[0m'
BOLD='\033[1m'

# Default paths
SECRETS_DIR="$HOME/.ade/secrets"
KEYS_DIR="$HOME/.ade/keys"
ENCRYPTED_DIR="$HOME/.ade/encrypted"

# Ensure directories exist
mkdir -p "$SECRETS_DIR" "$KEYS_DIR" "$ENCRYPTED_DIR"
chmod 700 "$SECRETS_DIR" "$KEYS_DIR" "$ENCRYPTED_DIR"

# Show usage
show_help() {
    echo -e "${BOLD}${CYAN}ADE-Crypt - Encryption Utility${NC}"
    echo ""
    echo "Usage: ade-crypt <command> [options]"
    echo ""
    echo -e "${BOLD}Commands:${NC}"
    echo "  encrypt <file>         Encrypt a file or directory"
    echo "  decrypt <file>         Decrypt a file or directory"
    echo "  store <name>           Store a secret securely"
    echo "  get <name>             Retrieve a stored secret"
    echo "  list                   List stored secrets"
    echo "  delete <name>          Delete a stored secret"
    echo "  generate-key           Generate encryption key"
    echo "  rotate-keys            Rotate encryption keys"
    echo "  lock                   Lock all secrets (encrypt with master key)"
    echo "  unlock                 Unlock all secrets"
    echo "  backup                 Backup encrypted secrets"
    echo "  restore <backup>       Restore from backup"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  -k, --key <file>       Use specific key file"
    echo "  -o, --output <file>    Output to specific file"
    echo "  -r, --recursive        Encrypt directory recursively"
    echo "  -s, --shred            Shred original after encryption"
    echo "  -p, --password         Use password-based encryption"
    echo "  -a, --armor            ASCII armor output (base64)"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  ade-crypt encrypt sensitive.txt"
    echo "  ade-crypt decrypt sensitive.txt.enc"
    echo "  ade-crypt store github-token"
    echo "  ade-crypt get github-token"
    echo "  ade-crypt encrypt -r ./secrets-folder"
}

# Check for required tools
check_dependencies() {
    local missing=()
    
    command -v openssl >/dev/null 2>&1 || missing+=("openssl")
    command -v gpg >/dev/null 2>&1 || missing+=("gpg")
    
    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}Missing required tools: ${missing[*]}${NC}"
        echo "Install with: sudo apt-get install ${missing[*]}"
        exit 1
    fi
}

# Generate encryption key
generate_key() {
    local key_name="${1:-default}"
    local key_file="$KEYS_DIR/${key_name}.key"
    
    echo -e "${CYAN}Generating encryption key: $key_name${NC}"
    
    # Generate 256-bit key
    openssl rand -base64 32 > "$key_file"
    chmod 600 "$key_file"
    
    echo -e "${GREEN}✓ Key generated: $key_file${NC}"
    echo -e "${YELLOW}⚠️  Keep this key safe! Losing it means losing access to encrypted data${NC}"
}

# Encrypt file
encrypt_file() {
    local input_file="$1"
    local output_file="${2:-${input_file}.enc}"
    local key_file="${KEY_FILE:-$KEYS_DIR/default.key}"
    
    if [ ! -f "$input_file" ]; then
        echo -e "${RED}File not found: $input_file${NC}"
        exit 1
    fi
    
    # Generate key if it doesn't exist
    if [ ! -f "$key_file" ]; then
        echo -e "${YELLOW}No key found, generating one...${NC}"
        generate_key "default"
    fi
    
    echo -e "${CYAN}Encrypting: $input_file${NC}"
    
    if [ "$USE_PASSWORD" = true ]; then
        # Password-based encryption
        gpg --symmetric --cipher-algo AES256 --output "$output_file" "$input_file"
    else
        # Key-based encryption
        openssl enc -aes-256-cbc -salt -in "$input_file" -out "$output_file" -pass file:"$key_file"
    fi
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Encrypted: $output_file${NC}"
        
        if [ "$SHRED_ORIGINAL" = true ]; then
            echo -e "${YELLOW}Shredding original file...${NC}"
            shred -vzu "$input_file" 2>/dev/null || rm -f "$input_file"
        fi
    else
        echo -e "${RED}Encryption failed${NC}"
        exit 1
    fi
}

# Decrypt file
decrypt_file() {
    local input_file="$1"
    local output_file="${2:-${input_file%.enc}}"
    local key_file="${KEY_FILE:-$KEYS_DIR/default.key}"
    
    if [ ! -f "$input_file" ]; then
        echo -e "${RED}File not found: $input_file${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}Decrypting: $input_file${NC}"
    
    if [ "$USE_PASSWORD" = true ]; then
        # Password-based decryption
        gpg --decrypt --output "$output_file" "$input_file"
    else
        # Key-based decryption
        if [ ! -f "$key_file" ]; then
            echo -e "${RED}Key not found: $key_file${NC}"
            exit 1
        fi
        openssl enc -aes-256-cbc -d -in "$input_file" -out "$output_file" -pass file:"$key_file"
    fi
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Decrypted: $output_file${NC}"
    else
        echo -e "${RED}Decryption failed${NC}"
        exit 1
    fi
}

# Encrypt directory
encrypt_directory() {
    local dir="$1"
    local output="${2:-${dir}.tar.enc}"
    
    if [ ! -d "$dir" ]; then
        echo -e "${RED}Directory not found: $dir${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}Encrypting directory: $dir${NC}"
    
    # Create tar archive and encrypt
    tar czf - "$dir" | openssl enc -aes-256-cbc -salt -out "$output" -pass file:"$KEYS_DIR/default.key"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Directory encrypted: $output${NC}"
        
        if [ "$SHRED_ORIGINAL" = true ]; then
            echo -e "${YELLOW}Removing original directory...${NC}"
            rm -rf "$dir"
        fi
    else
        echo -e "${RED}Encryption failed${NC}"
        exit 1
    fi
}

# Decrypt directory
decrypt_directory() {
    local input="$1"
    local output_dir="${2:-.}"
    
    if [ ! -f "$input" ]; then
        echo -e "${RED}File not found: $input${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}Decrypting directory archive: $input${NC}"
    
    # Decrypt and extract
    openssl enc -aes-256-cbc -d -in "$input" -pass file:"$KEYS_DIR/default.key" | tar xzf - -C "$output_dir"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Directory decrypted to: $output_dir${NC}"
    else
        echo -e "${RED}Decryption failed${NC}"
        exit 1
    fi
}

# Store secret
store_secret() {
    local name="$1"
    local secret_file="$SECRETS_DIR/${name}.enc"
    
    if [ -z "$name" ]; then
        echo -e "${RED}Please provide a secret name${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}Enter secret value for '$name' (press Ctrl+D when done):${NC}"
    
    # Read secret from stdin
    local secret
    secret=$(cat)
    
    # Encrypt and store
    echo -n "$secret" | openssl enc -aes-256-cbc -salt -out "$secret_file" -pass file:"$KEYS_DIR/default.key"
    chmod 600 "$secret_file"
    
    echo -e "${GREEN}✓ Secret stored: $name${NC}"
}

# Get secret
get_secret() {
    local name="$1"
    local secret_file="$SECRETS_DIR/${name}.enc"
    
    if [ ! -f "$secret_file" ]; then
        echo -e "${RED}Secret not found: $name${NC}"
        exit 1
    fi
    
    # Decrypt and output
    openssl enc -aes-256-cbc -d -in "$secret_file" -pass file:"$KEYS_DIR/default.key"
}

# List secrets
list_secrets() {
    echo -e "${CYAN}Stored secrets:${NC}"
    
    if [ -z "$(ls -A $SECRETS_DIR 2>/dev/null)" ]; then
        echo "  (none)"
    else
        for file in "$SECRETS_DIR"/*.enc; do
            [ -f "$file" ] || continue
            basename "$file" .enc | sed 's/^/  • /'
        done
    fi
}

# Delete secret
delete_secret() {
    local name="$1"
    local secret_file="$SECRETS_DIR/${name}.enc"
    
    if [ ! -f "$secret_file" ]; then
        echo -e "${RED}Secret not found: $name${NC}"
        exit 1
    fi
    
    echo -ne "${YELLOW}Delete secret '$name'? (y/n): ${NC}"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        shred -vzu "$secret_file" 2>/dev/null || rm -f "$secret_file"
        echo -e "${GREEN}✓ Secret deleted: $name${NC}"
    else
        echo "Cancelled"
    fi
}

# Rotate keys
rotate_keys() {
    echo -e "${CYAN}Rotating encryption keys...${NC}"
    
    # Generate new key
    local new_key="$KEYS_DIR/default.key.new"
    openssl rand -base64 32 > "$new_key"
    chmod 600 "$new_key"
    
    # Re-encrypt all secrets
    for file in "$SECRETS_DIR"/*.enc; do
        [ -f "$file" ] || continue
        
        local temp_file="${file}.tmp"
        local name=$(basename "$file" .enc)
        
        echo "  Re-encrypting: $name"
        
        # Decrypt with old key, encrypt with new key
        openssl enc -aes-256-cbc -d -in "$file" -pass file:"$KEYS_DIR/default.key" | \
        openssl enc -aes-256-cbc -salt -out "$temp_file" -pass file:"$new_key"
        
        if [ $? -eq 0 ]; then
            mv "$temp_file" "$file"
        else
            echo -e "${RED}Failed to rotate: $name${NC}"
            rm -f "$temp_file"
            rm -f "$new_key"
            exit 1
        fi
    done
    
    # Backup old key and activate new one
    mv "$KEYS_DIR/default.key" "$KEYS_DIR/default.key.old"
    mv "$new_key" "$KEYS_DIR/default.key"
    
    echo -e "${GREEN}✓ Keys rotated successfully${NC}"
    echo -e "${YELLOW}Old key backed up to: $KEYS_DIR/default.key.old${NC}"
}

# Backup secrets
backup_secrets() {
    local backup_name="ade-secrets-$(date +%Y%m%d-%H%M%S).tar.gz"
    local backup_path="$HOME/${backup_name}"
    
    echo -e "${CYAN}Creating backup...${NC}"
    
    tar czf "$backup_path" -C "$HOME/.ade" secrets keys
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Backup created: $backup_path${NC}"
        echo -e "${YELLOW}Store this backup securely!${NC}"
    else
        echo -e "${RED}Backup failed${NC}"
        exit 1
    fi
}

# Restore from backup
restore_backup() {
    local backup_file="$1"
    
    if [ ! -f "$backup_file" ]; then
        echo -e "${RED}Backup file not found: $backup_file${NC}"
        exit 1
    fi
    
    echo -ne "${YELLOW}This will overwrite existing secrets. Continue? (y/n): ${NC}"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        echo -e "${CYAN}Restoring from backup...${NC}"
        tar xzf "$backup_file" -C "$HOME/.ade"
        echo -e "${GREEN}✓ Backup restored${NC}"
    else
        echo "Cancelled"
    fi
}

# Parse arguments
COMMAND="${1:-help}"
shift || true

USE_PASSWORD=false
SHRED_ORIGINAL=false
KEY_FILE=""
OUTPUT_FILE=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        -k|--key)
            KEY_FILE="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -p|--password)
            USE_PASSWORD=true
            shift
            ;;
        -s|--shred)
            SHRED_ORIGINAL=true
            shift
            ;;
        -r|--recursive)
            RECURSIVE=true
            shift
            ;;
        -a|--armor)
            ARMOR=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Check dependencies
check_dependencies

# Execute command
case "$COMMAND" in
    encrypt)
        if [ -d "$1" ] || [ "$RECURSIVE" = true ]; then
            encrypt_directory "$1" "$OUTPUT_FILE"
        else
            encrypt_file "$1" "$OUTPUT_FILE"
        fi
        ;;
    decrypt)
        if [[ "$1" == *.tar.enc ]]; then
            decrypt_directory "$1" "$OUTPUT_FILE"
        else
            decrypt_file "$1" "$OUTPUT_FILE"
        fi
        ;;
    store)
        store_secret "$1"
        ;;
    get)
        get_secret "$1"
        ;;
    list)
        list_secrets
        ;;
    delete)
        delete_secret "$1"
        ;;
    generate-key)
        generate_key "$1"
        ;;
    rotate-keys)
        rotate_keys
        ;;
    backup)
        backup_secrets
        ;;
    restore)
        restore_backup "$1"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: $COMMAND${NC}"
        echo ""
        show_help
        exit 1
        ;;
esac